<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings" /><meta name="author" content="saha" /><meta property="og:locale" content="en" /><meta name="description" content="Abstract" /><meta property="og:description" content="Abstract" /><link rel="canonical" href="https://ee12ha0220.github.io/posts/KPCN/" /><meta property="og:url" content="https://ee12ha0220.github.io/posts/KPCN/" /><meta property="og:site_name" content="Saha’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-02T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@saha" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"saha","url":"https://github.com/ee12ha0220/"},"dateModified":"2022-04-02T00:00:00+09:00","datePublished":"2022-04-02T00:00:00+09:00","description":"Abstract","headline":"Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings","mainEntityOfPage":{"@type":"WebPage","@id":"https://ee12ha0220.github.io/posts/KPCN/"},"url":"https://ee12ha0220.github.io/posts/KPCN/"}</script><title>Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings | Saha's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Saha's Blog"><meta name="application-name" content="Saha's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/images/avatar_2.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Saha's Blog</a></div><div class="site-subtitle font-italic">공부한 것들을 까먹지 말자</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/ee12ha0220" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['ee12ha0220','kaist.ac.kr'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1648825200" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 2, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/ee12ha0220/">saha</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1499 words"> <em>8 min</em> read</span></div></div></div><div class="post-content"><h1 id="abstract">Abstract</h1><p>Regression-based algorithms have shown to be good at denoising Monte Carlo (MC) renderings by leveraging its inexpensive by-products (e.g., feature buffers). However, when using higher-order models to handle complex cases, these techniques often overfit to noise in the input. For this reason, supervised learning methods have been proposed that train on a large collection of reference examples, but they use explicit filters that limit their denoising ability. To address these problems, we propose a novel, supervised learning approach that allows the filtering kernel to be more complex and general by leveraging a deep convolutional neural network (CNN) architecture. In one embodiment of our framework, the CNN directly predicts the final denoised pixel value as a highly non-linear combination of the input features. In a second approach, we introduce a novel, kernel-prediction network which uses the CNN to estimate the local weighting kernels used to compute each denoised pixel from its neighbors. We train and evaluate our networks on production data and observe improvements over state-of-the art MC denoisers, showing that our methods generalize well to a variety of scenes. We conclude by analyzing various components of our architecture and identify areas of further research in deep learning for MC denoising.</p><h1 id="introduction">Introduction</h1><h2 id="monte-carlo-denoising"><span class="mr-2">Monte Carlo denoising</span><a href="#monte-carlo-denoising" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>보다 더 정확한 image를 생성하기 위해, 과거에 사용하던 REYES-style micropolygon architecture[Cook et al. 1987]에서 physically-based Monte Carlo (MC) path tracing [Kajiya 1986] 으로 많이 넘어오고 있다. 이 방법은 ray tracing을 사용하며, rendering equation의 적분을 쉽게 하기 위해 Monte Carlo integration을 사용한다(\ref{eq1}).</p><hr /> \[L_o(p,\omega_o) = \int_{\Omega^{+}} L_i(p, \omega_i)f_r(p,\omega_i,\omega_o)(n\cdot\omega_i)\mathbf{d}\omega_i \approx \frac{1}{N}\sum^{N}_{i=1}\frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot\omega_i)}{p(\omega_i)} \label{eq1} \tag{1}\]<hr /><p>Monte Carlo integration은 unbiased estimator이기 때문에, sample의 개수($N$)이 많다는 전제 하에 ground truth로 수렴하게 된다. 하지만 많은 spp(sample per pixel)을 사용하면 그만큼 시간이 오래 걸리게 되는데, 그래서 적은 spp로 noisy image를 뽑아내고, 여기에 denoising을 통해 clean image를 얻어내는 <strong>Monte Carlo denoising</strong> 이 연구되고 있다.</p><h2 id="previous-works"><span class="mr-2">Previous works</span><a href="#previous-works" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Monte Carlo renderer에서 만들어진 image의 각 pixel 값 $\mathbf{x}_p \in\mathbb{R}^{3+D}$는 pixel당 RGB color을 나타내는 $c_p$, surface normal, depth, albedo, 그리고 이들의 variance정보를 담고 있는 D auxiliary features $\mathbf{f}_p$ 로 이루어져 있다. MC denoising에서 filtered color $\hat{c}_p$ 는 pixel $p$의 neighborhood $\mathcal{N}_p$에 속하는 per-pixel vector들인 $\mathbf{X}_p$와 CNN network를 이용해서 얻어지며, 이를 ground truth color $\bar{c}_p$ 와 가깝게 만드는 weight을 찾는 것을 목표로 한다(\ref{eq2}).</p><hr /> \[\hat{c}_p = g(\mathbf{X}_p;\hat{\theta}_p), \quad \hat{\theta}_p = \underset{\theta}{\text{argmin }} \mathcal{l}(\bar{c}_p, \hat{c}_p) \label{eq2} \tag{2}\]<hr /><p>하지만 이 과정에서 ground truth 값을 얻을 수 없기 때문에, 기존의 MC denoising 방법들은 $\mathcal{N}_p$에 속하는 다른 값들을 reference로 weight를 정했다(\ref{eq3}).</p><hr /> \[\hat{c}_p = {\hat{\theta}}_p^\top \phi(\mathbf{x}_p), \quad \hat{\theta}_p = \underset{\theta}{\text{argmin}} \sum_{q\in\mathcal{N}(p)} (\mathbf{c}_q - {\theta}_p^\top \phi(\mathbf{x}_q))\omega({\mathbf{x}_p, \mathbf{x}_q}) \label{eq3} \tag{3}\]<hr /><p>이때 $\omega({\mathbf{x}_p, \mathbf{x}_q})$ 는 일종의 regression kernel로, noise로 인해 심하게 변한 value들을 무시하게 해준다.</p><p>점점 더 복잡한 $\phi$ 를 사용하는 방법들이 시도되었지만, 이는 특정 image에 over-fitting될 가능성이 높았기 때문에 그 한계를 보였다.</p><p>그래서 Kalanari et al.[2015] 에서는 이를 해결하기 위해 supervised learning을 도입했는데, over-fitting을 막기 위해 전체 dataset을 $N$개의 patch들로 나눠서 그 평균을 이용해 학습을 했다(\ref{eq4}).</p><hr /> \[\hat{\theta} = \underset{\theta}{\text{argmin}} \frac{1}{N}\sum^{N}_{i=1}\mathcal{l}(\bar{c}_i, g(\mathbf{X}_i;\theta)) \label{eq4} \tag{4}\]<hr /><p>하지만 이 경우에도 결국에는 고정된 filter을 사용했기 때문에, 표현에 한계가 존재했다. 더 flexible한 g를 사용하기 위해 이 논문에서는 <strong>Convolutional Neural Network(CNN)</strong>을 도입했다.</p><h1 id="deep-convolutional-denoising">Deep convolutional denoising</h1><h2 id="network-architecture"><span class="mr-2">Network architecture</span><a href="#network-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 논문에서는 parameter의 개수를 적게 하기 위해서 fully connected layer을 사용하지 않고 오직 CNN만을 사용했다. 이는 over-fitting의 위험을 줄여줄 뿐만 아니라, training, inference speed를 모두 빠르게 해준다.</p><p>각 layer사이의 activation function에는 ReLU가 사용되었고, 마지막에만 identity function이 사용되었다.</p><h2 id="reconstruction-methods"><span class="mr-2">Reconstruction methods</span><a href="#reconstruction-methods" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Function g의 output에 따라 <strong>direct-prediction(DPCN)</strong> 과 <strong>kernel-prediction(KPCN)</strong> 으로 나뉠 수 있다.</p><p>먼저 <strong>DPCN</strong>은 말 그대로 clean image자체를 얻는 것을 목표로 한다. 논문에 따르면 이 방법은 좋은 성능을 보였지만, optimization 과정에서 converge 속도가 엄청 느렸다고 한다.</p><p>반면에 <strong>KPCN</strong>은 각 neighborhood에 맞는 특정한 kernel을 얻는 것을 목표로 한다. Kernel의 weight들은 마지막에 softmax function을 통해 normalize되는데, 이는 최종 clean image의 각 pixel의 값이 색의 범위를 벗어나지 않도록 해주고, gradient를 안정화시켜서 converge 속도 향상에 도움을 준다고 한다.</p><h2 id="diffusespecular-decomposition"><span class="mr-2">Diffuse/Specular decomposition</span><a href="#diffusespecular-decomposition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>MC denoising을 거친 결과물은 over-blurring되는 경우가 많이 있는데, 이는 image에 존재하는 noise들의 원인과 특성이 다 제각기이기 때문에, denoising하는 데에 있어서 conflict를 일으키기 때문이다. 그래서 이 논문에서는 image를 diffuse, specular components으로 나눠서 이 현상을 줄이고자 했다.</p><p>Diffuse components는 오차의 범위가 크지 않기 때문에 color preprocessing 없이도 좋은 결과를 보였다고 한다. 실제 실험에서는 noisy albedo 부분을 제거해줘서 irradiance 부분만 CNN에게 전달해줬다(\ref{eq5}).</p><hr /> \[\tilde{\mathbf{c}}_\text{diffuse} = {\mathbf{c}}_{\text{diffuse}} / (\mathbf{f}_\text{albedo} + \epsilon) \label{eq5} \tag{5}\]<hr /><p>이때 $\epsilon$은 0으로 나누는 것을 막기 위한 상수이다.</p><p>Specular components는 오차의 범위가 컸기 때문에, log scale로 만들어줘서 이를 완화시켰다(\ref{eq6}).</p><hr /> \[\tilde{\mathbf{c}}_\text{specular} = \log(1 + \mathbf{c}_{\text{specular}}) \label{eq6} \tag{6}\]<hr /><p>Clean image로 restoration하는 과정에서는 아래의 역변환을 거쳤다(\ref{eq7}).</p><hr /> \[\hat{c} = (\mathbf{f}_\text{albedo} + \epsilon) * \hat{\mathbf{c}}_\text{diffuse} + \text{exp}(\hat{\mathbf{c}}_\text{specular})-1 \label{eq7} \tag{7}\]<hr /><h1 id="training">Training</h1><p>9개의 convolution layer을 사용했으며, 각 layer은 100개의 channel과 $5\times5$ 크기의 kernel을 갖고 있다. 마지막 output kernel의 크기는 $21\times21$ 로, 최종 layer의 channel 수는 $21^2$이 된다. Input data는 $1280\times1280$ 크기의 image로, diffuse color + variance(4), specular color + variance(4), diffuse color derivative(6), specular color derivative(6), normals + variance(4), normals derivative(6), albedo + variance(4), albedo derivative(6), depth + variance(2), depth derivative(2)로 총 44개의 channel이 있다. 앞서 설명했듯이 diffuse, specular로 나눠서 2개의 model을 학습하기 때문에, 각 model에는 34개의 channel이 input으로 들어가게 된다.</p><h1 id="result">Result</h1><p>Refer to <a href="http://disneyresearch.s3.amazonaws.com/wp-content/uploads/20170630135237/Kernel-Predicting-Convolutional-Networks-for-Denoising-Monte-Carlo-Renderings-Paper33.pdf">original paper</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/paper-review/'>Paper review</a>, <a href='/categories/mc-denoising/'>MC denoising</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Kernel-Predicting+Convolutional+Networks+for+Denoising+Monte+Carlo+Renderings+-+Saha%27s+Blog&url=https%3A%2F%2Fee12ha0220.github.io%2Fposts%2FKPCN%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Kernel-Predicting+Convolutional+Networks+for+Denoising+Monte+Carlo+Renderings+-+Saha%27s+Blog&u=https%3A%2F%2Fee12ha0220.github.io%2Fposts%2FKPCN%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fee12ha0220.github.io%2Fposts%2FKPCN%2F&text=Kernel-Predicting+Convolutional+Networks+for+Denoising+Monte+Carlo+Renderings+-+Saha%27s+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/DDPM/">Denoising Diffusion Probabilistic Models</a><li><a href="/posts/SMLD/">Generative Modeling by Estimating Gradients of the Data Distribution</a><li><a href="/posts/DDIM/">DENOISING DIFFUSION IMPLICIT MODELS</a><li><a href="/posts/fn/">각종 코드 정리</a><li><a href="/posts/MLMC/">A Machine Learning Approach for Filtering Monte Carlo Noise</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tag/">tag</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/MLMC/"><div class="card-body"> <em class="small" data-ts="1652108400" data-df="ll" > May 10, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>A Machine Learning Approach for Filtering Monte Carlo Noise</h3><div class="text-muted small"><p> Abstract The most successful approaches for filtering Monte Carlo noise use feature-based filters (e.g., cross-bilateral and cross non-local means filters) that exploit additional scene features s...</p></div></div></a></div><div class="card"> <a href="/posts/SBMC/"><div class="card-body"> <em class="small" data-ts="1649343600" data-df="ll" > Apr 8, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Sample-based Monte Carlo Denoising using a Kernel-Splatting Network</h3><div class="text-muted small"><p> Abstract Denoising has proven to be useful to efficiently generate high-quality Monte Carlo renderings. Traditional pixel-based denoisers exploit summary statistics of a pixel’s sample distributio...</p></div></div></a></div><div class="card"> <a href="/posts/LBMC/"><div class="card-body"> <em class="small" data-ts="1650121200" data-df="ll" > Apr 17, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Neural Denoising with Layer Embeddings</h3><div class="text-muted small"><p> Abstract We propose a novel approach for denoising Monte Carlo path traced images, which uses data from individual samples rather than relying on pixel aggregates. Samples are partitioned into lay...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/iNeRF/" class="btn btn-outline-primary" prompt="Older"><p>iNeRF: Inverting Neural Radiance Fields for Pose Estimation</p></a> <a href="/posts/SBMC/" class="btn btn-outline-primary" prompt="Newer"><p>Sample-based Monte Carlo Denoising using a Kernel-Splatting Network</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">Seeha Lee</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tag/">tag</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
